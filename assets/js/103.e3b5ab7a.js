(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{507:function(v,_,a){"use strict";a.r(_);var t=a(42),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"微前端概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端概念"}},[v._v("#")]),v._v(" 微前端概念")]),v._v(" "),a("p",[v._v("微前端是将微服务理念应用于前端技术后的相关实践，使得一个前端项目可以由多个团队独立开发以及独立部署。")]),v._v(" "),a("h2",{attrs:{id:"微前端的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端的特性"}},[v._v("#")]),v._v(" 微前端的特性")]),v._v(" "),a("ul",[a("li",[v._v("技术无关")])]),v._v(" "),a("p",[v._v("各个开发团队可以自行选择技术栈，不受同一项目中其它团队影响。")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("代码独立\n各个交付的产物都可以被独立使用，避免和其它交付产物耦合。")])]),v._v(" "),a("li",[a("p",[v._v("样式隔离\n各个交付产物中的样式不会污染到其它组件。")])]),v._v(" "),a("li",[a("p",[v._v("原生支持\n各个交付产物都可以自由使用浏览器原生 API，而非要求使用封装后的 API。")])])]),v._v(" "),a("h2",{attrs:{id:"微前端解决的核心问题和步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端解决的核心问题和步骤"}},[v._v("#")]),v._v(" 微前端解决的核心问题和步骤")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("一个前端需要对应多个后端")])]),v._v(" "),a("li",[a("p",[v._v("提供一套应用注册机制，完成应用的无缝整合")])]),v._v(" "),a("li",[a("p",[v._v("在应用之前对开发者要指定好使用 CSR 或 SSR 的技术方案")])]),v._v(" "),a("li",[a("p",[v._v("构建时集成应用和应用独立发布部署")])])]),v._v(" "),a("p",[v._v("具体来说：")]),v._v(" "),a("ol",[a("li",[v._v("微应用的注册、异步加载和生命周期管理")]),v._v(" "),a("li",[v._v("微应用之间、主从之间的消息机制")]),v._v(" "),a("li",[v._v("微应用之间的安全隔离措施")]),v._v(" "),a("li",[v._v("微应用的框架无关、版本无关")]),v._v(" "),a("li",[v._v("微应用之间、主从之间的公共依赖的库、业务逻辑（utils）以及版本怎么管理")]),v._v(" "),a("li",[v._v("微应用独立调试、和主应用联调的方式，快速定位报错")]),v._v(" "),a("li",[v._v("微应用的发布流程")]),v._v(" "),a("li",[v._v("微应用打包优化问题")]),v._v(" "),a("li",[v._v("微应用专有云场景的出包方案")]),v._v(" "),a("li",[v._v("渐进式升级。用微应用方案平滑重构老项目")])]),v._v(" "),a("h2",{attrs:{id:"微前端交付产物"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端交付产物"}},[v._v("#")]),v._v(" 微前端交付产物")]),v._v(" "),a("ul",[a("li",[v._v("发布静态资源+后台路由和服务")]),v._v(" "),a("li",[v._v("发布组件启动时机全由父级决定")]),v._v(" "),a("li",[v._v("发布局部应用配置过程由自身决定")])]),v._v(" "),a("h2",{attrs:{id:"常见的部署方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的部署方式"}},[v._v("#")]),v._v(" 常见的部署方式")]),v._v(" "),a("ul",[a("li",[v._v("大仓库拆分成独立的模块，统一构建")]),v._v(" "),a("li",[v._v("大仓库通过 monorepo methodology 做成 npm 包，集成到主项目")]),v._v(" "),a("li",[v._v("大仓库拆分成子仓库，构建出独立的服务/应用")]),v._v(" "),a("li",[v._v("大仓库拆分成多仓库，构建后集成到主应用")])]),v._v(" "),a("h2",{attrs:{id:"微前端常见方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端常见方案"}},[v._v("#")]),v._v(" 微前端常见方案")]),v._v(" "),a("h3",{attrs:{id:"iframe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iframe"}},[v._v("#")]),v._v(" iframe")]),v._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),a("p",[v._v("改造成本低，可以快速上线")]),v._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),a("ul",[a("li",[v._v("不可控制。iframe 嵌入的显示区大小不容易控制，存在一定的局限性")]),v._v(" "),a("li",[v._v("刷新问题。URL 的记录完全无效，页面刷新不能被记忆，刷新会返回首页，iframe 功能之间跳转也无效")]),v._v(" "),a("li",[v._v("兼容性差。iframe 的样式显示、兼容性都具有局限性")]),v._v(" "),a("li",[v._v("性能开销。iframe 阻塞 onload、占用连接池、多层嵌套页面崩溃、内存占用大（每开一个 iframe 相当于多创建了一个进程）。实测在 Android 手机上多开 iframe 内存从 90M 飙升到了 400 多 M。")])]),v._v(" "),a("h3",{attrs:{id:"百度-fis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#百度-fis"}},[v._v("#")]),v._v(" 百度 FIS")]),v._v(" "),a("p",[v._v("百度的 fis 其实是一个不错的解决方案。只是缺少更新维护了。")]),v._v(" "),a("h3",{attrs:{id:"system-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#system-js"}},[v._v("#")]),v._v(" System.js")]),v._v(" "),a("p",[v._v("目前为止较好的方案。\n各个子应用独立开发部署，唯一需要改变的地方就是 webpack 的配置，侵入性很小。主项目通过 system.js 引入子应用。")]),v._v(" "),a("h3",{attrs:{id:"webpack5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack5"}},[v._v("#")]),v._v(" Webpack5")]),v._v(" "),a("p",[v._v("Webpack5 原生支持微前端，通过"),a("code",[v._v("ModuleFederationPlugin")]),v._v("配置主项目")]),v._v(" "),a("h3",{attrs:{id:"webcomponents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webcomponents"}},[v._v("#")]),v._v(" WebComponents")]),v._v(" "),a("p",[v._v("通过 webcomponents，需要哪个组件，直接引入即可，自动的 CSS 沙箱隔离。缺点是旧的浏览器兼容性差，但是是未来趋势。")]),v._v(" "),a("h3",{attrs:{id:"流行的库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流行的库"}},[v._v("#")]),v._v(" 流行的库")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("bifrost")])]),v._v(" "),a("li",[a("p",[v._v("single-spa")])]),v._v(" "),a("li",[a("p",[v._v("qiankun\n乾坤提供了样式隔离（scope），JS 沙箱隔离（proxy）。\n1.vue react 项目配合自己 暴露生命周期 全局的把你的项目名字 通过 Window 暴露出来 2.获取子应用的 HTML 填充到 HTML 里面 3.创建沙箱运行环节 Proxy 代理了 window 上的内容 填了一层 4.执行自定义的生命周期 挂载到沙箱 5.卸载沙箱 生命周期注册流程 single-spa")])]),v._v(" "),a("li",[a("p",[v._v("基于 serverless 的服务")])]),v._v(" "),a("li",[a("p",[v._v("omi")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);