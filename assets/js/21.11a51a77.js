(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{417:function(a,t,e){a.exports=e.p+"assets/img/gzip_can_i_use.e3b534d2.png"},521:function(a,t,e){"use strict";e.r(t);var s=e(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"雅虎军规"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#雅虎军规"}},[a._v("#")]),a._v(" 雅虎军规")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://developer.yahoo.com/performance/rules.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Best Practices for Speeding Up Your Web Site 原文链接"),s("OutboundLink")],1),a._v("\nYahoo性能优化团队总结了让网页更快的七大类35条最佳实践。")]),a._v(" "),s("h2",{attrs:{id:"_1-减少http请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-减少http请求"}},[a._v("#")]),a._v(" 1. 减少HTTP请求")]),a._v(" "),s("p",[a._v("80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。")]),a._v(" "),s("p",[a._v("减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？下面是一些较少HTTP请求的同时也支持复杂页面设计的技巧。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("合并文件。合并文件是将所有的scripts都合并到一个script中，一般保留3-5个js。类似的也可以将所有的CSS合并到一个stylesheet中。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。")])]),a._v(" "),s("li",[s("p",[a._v("CSS Sprites（雪碧图）。CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。")])]),a._v(" "),s("li",[s("p",[a._v("Image maps。图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。")])]),a._v(" "),s("li",[s("p",[a._v("Inline images 。 行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。")])])]),a._v(" "),s("h2",{attrs:{id:"_2-使用cdn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用cdn"}},[a._v("#")]),a._v(" 2. 使用CDN")]),a._v(" "),s("p",[a._v("CDN是Content Delivery Network的缩写。用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？")]),a._v(" "),s("p",[a._v("实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。")]),a._v(" "),s("p",[a._v("记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。")]),a._v(" "),s("p",[a._v("内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。")]),a._v(" "),s("h2",{attrs:{id:"_3-添加expires或者cache-control-http头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-添加expires或者cache-control-http头"}},[a._v("#")]),a._v(" 3. 添加Expires或者Cache-Control HTTP头")]),a._v(" "),s("p",[a._v("这条规则有两个方面：")]),a._v(" "),s("ul",[s("li",[a._v("对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效")]),a._v(" "),s("li",[a._v("对余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求\n网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。")])]),a._v(" "),s("p",[a._v("浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。")]),a._v(" "),s("p",[s("code",[a._v("Expires: Thu, 15 Apr 2010 20:00:00 GMT")])]),a._v(" "),s("p",[a._v("如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：")]),a._v(" "),s("p",[s("code",[a._v('ExpiresDefault "access plus 10 years"')])]),a._v(" "),s("h2",{attrs:{id:"_4-gzip组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-gzip组件"}},[a._v("#")]),a._v(" 4. Gzip组件")]),a._v(" "),s("p",[a._v("前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。")]),a._v(" "),s("p",[a._v("从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。")]),a._v(" "),s("p",[s("code",[a._v("Accept-Encoding: gzip, deflate")])]),a._v(" "),s("p",[a._v("如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。")]),a._v(" "),s("p",[s("code",[a._v("Content-Encoding: gzip")])]),a._v(" "),s("p",[a._v("Gzip是当前最流行也是最有效的压缩方法。它大约可以减少70%左右的response大小。浏览器对于Gzip的支持如下：\n"),s("img",{attrs:{src:e(417),alt:""}})]),a._v(" "),s("p",[a._v("服务器会根据文件类型选择gzip内容，但通常在决定压缩内容方面受到限制。大部分web站点会gzip Html。gzip脚本和样式表也是值得的，但是许多网站都没有这么做。实际上，压缩任何文本响应（包括XML和JSON）都是值得的。图片和PDF文件不应压缩，因为它们已经被压缩。尝试对其进行gzip压缩不仅浪费CPU，而且可能会增加文件大小")]),a._v(" "),s("p",[a._v("压缩尽可能多的文件类型是减轻页面大小和加快用户体验的简便方法。")]),a._v(" "),s("h2",{attrs:{id:"_5-把样式表放在顶部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-把样式表放在顶部"}},[a._v("#")]),a._v(" 5. 把样式表放在顶部")]),a._v(" "),s("p",[a._v("在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。")]),a._v(" "),s("p",[a._v("关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。")]),a._v(" "),s("h2",{attrs:{id:"_6-把脚本放在底部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-把脚本放在底部"}},[a._v("#")]),a._v(" 6. 把脚本放在底部")]),a._v(" "),s("p",[a._v("脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。")]),a._v(" "),s("p",[a._v("有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。")]),a._v(" "),s("p",[a._v("一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。")]),a._v(" "),s("h2",{attrs:{id:"_7-避免css表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-避免css表达式"}},[a._v("#")]),a._v(" 7. 避免CSS表达式")]),a._v(" "),s("p",[a._v("用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v(' background-color: expression( (new Date()).getHours()%2 ? "#B8D4FF" : "#F08A00" );\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("使用CSS表达式的问题在于，它比我们想象的要执行的更频繁。这些表达式吧不仅在页面重新渲染或者resize的时候会执行，在页面滚动甚至是鼠标移动到页面时都会执行。")]),a._v(" "),s("p",[a._v("如果一定要使用CSS表达式，一个减少执行次数的方法是在第一次执行完后把表达式替换为静态属性。但是这样就做不到动态修改了。如果需要动态修改，可以把修改的事件放到组件的生命周期，或者各种event handler中。")]),a._v(" "),s("h2",{attrs:{id:"_8-把javascript和css放到外面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-把javascript和css放到外面"}},[a._v("#")]),a._v(" 8. 把JavaScript和CSS放到外面")]),a._v(" "),s("p",[a._v("很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？")]),a._v(" "),s("p",[a._v("实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。")]),a._v(" "),s("h2",{attrs:{id:"_9-减少dns查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-减少dns查找"}},[a._v("#")]),a._v(" 9. 减少DNS查找")]),a._v(" "),s("p",[a._v("域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。")]),a._v(" "),s("p",[a._v("DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。")]),a._v(" "),s("p",[a._v("IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)")]),a._v(" "),s("p",[a._v("如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。")]),a._v(" "),s("p",[a._v("减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。")]),a._v(" "),s("h2",{attrs:{id:"_10-压缩-javascript和css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-压缩-javascript和css"}},[a._v("#")]),a._v(" 10. 压缩 JavaScript和CSS")]),a._v(" "),s("p",[a._v("压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。")]),a._v(" "),s("p",[a._v("混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。")]),a._v(" "),s("p",[a._v("除了压缩外部脚本和样式，行内的"),s("script")])])}),[],!1,null,null,null);t.default=r.exports}}]);