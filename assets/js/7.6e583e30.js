(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{398:function(t,r,e){t.exports=e.p+"assets/img/render_engin.0e87e986.png"},399:function(t,r,e){t.exports=e.p+"assets/img/render_engin_work_flow.c945e4f1.png"},400:function(t,r,e){t.exports=e.p+"assets/img/chrome_framework.cdee62d0.png"},401:function(t,r,e){t.exports=e.p+"assets/img/chrome_render_process.93545180.png"},402:function(t,r,e){t.exports=e.p+"assets/img/chrome_render_dom.d9ffd2eb.png"},403:function(t,r,e){t.exports=e.p+"assets/img/chrome_render_raster.d6f27987.png"},404:function(t,r,e){t.exports=e.p+"assets/img/webkit.4a1e2605.png"},514:function(t,r,e){"use strict";e.r(r);var _=e(42),s=Object(_.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"chrome浏览器渲染机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#chrome浏览器渲染机制"}},[t._v("#")]),t._v(" Chrome浏览器渲染机制")]),t._v(" "),_("h2",{attrs:{id:"现代浏览器的结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#现代浏览器的结构"}},[t._v("#")]),t._v(" 现代浏览器的结构")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("用户界面")])]),t._v(" "),_("li",[_("p",[t._v("浏览器引擎。加载url，处理前进后退刷新等操作。同时还提供了很多hooks,帮助查看加载进度。")])]),t._v(" "),_("li",[_("p",[t._v("渲染引擎。主要负责页面可视化，它需要处理HTML和XML。XML是一种结构化文档。XML太重，解析很耗资源。XML解析手段有两种，一种是DOM解析，一种是SAX解析。DOM解析是完全按照节点结构在内存中生成DOM树。 SAX根据语义解析，不生成DOM，但是SAX处理方式太简单，不能满足复杂需求。浏览器的文档是比较复杂的，所以用的是DOM解析。渲染引擎还负责CSS的处理。CSS和DOM配合起来，会生成渲染树。渲染引擎还负责嵌入页面，计算页面布局。")])]),t._v(" "),_("li",[_("p",[t._v("网络。")])]),t._v(" "),_("li",[_("p",[t._v("JS解释器。在Google Chrome中是V8，在Safiri中是JS Core。")])]),t._v(" "),_("li",[_("p",[t._v("XML解析器")])]),t._v(" "),_("li",[_("p",[t._v("显示后端。负责界面绘图和显示的基本操作，字体、窗口等。")])]),t._v(" "),_("li",[_("p",[t._v("数据持久层。把内存的数据保存到硬盘中。")])])]),t._v(" "),_("h2",{attrs:{id:"常见的渲染引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的渲染引擎"}},[t._v("#")]),t._v(" 常见的渲染引擎")]),t._v(" "),_("p",[t._v("渲染引擎能够将HTML/CSS/JS文本及相应的资源文件转换成图像结果。")]),t._v(" "),_("ul",[_("li",[t._v("IE、Edge（旧）：Trident")]),t._v(" "),_("li",[t._v("Firefox: Gecko")]),t._v(" "),_("li",[t._v("Safari: Webkit")]),t._v(" "),_("li",[t._v("Chromium/Chrome, Opera, Edge(新): Blink(Webkit fork)")])]),t._v(" "),_("h2",{attrs:{id:"渲染引擎结构与工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎结构与工作流程"}},[t._v("#")]),t._v(" 渲染引擎结构与工作流程")]),t._v(" "),_("p",[t._v("渲染引擎以HTML/JS/CSS等文件作为输入，以可视化内容作为输出\n"),_("img",{attrs:{src:e(398),alt:""}}),t._v("\n渲染引擎内部主要做四步：")]),t._v(" "),_("ol",[_("li",[t._v("将HMTL初始化解析成DOM树，HTML参与。")]),t._v(" "),_("li",[t._v("生成渲染树。需要CSS参与")]),t._v(" "),_("li",[t._v("对渲染树进行布局。")]),t._v(" "),_("li",[t._v("绘制渲染树。")])]),t._v(" "),_("p",[t._v("下图是每步对应的内容。渲染引擎中两个核心的数据结构就是DOM树和渲染树，还有2个解析器，HTML解析器和CSS解析器，还有一个JS解释器。\n"),_("img",{attrs:{src:e(399),alt:""}})]),t._v(" "),_("p",[t._v("上面有个注意的地方，JS解释器和DOM树是有关系的。 JS有document对象，可以直接操作DOM，改变DOM结构。同时JS也可以读取DOM数据。DOM树修改了，渲染树需要重新生成。")]),t._v(" "),_("h2",{attrs:{id:"chrome架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#chrome架构"}},[t._v("#")]),t._v(" Chrome架构")]),t._v(" "),_("p",[_("img",{attrs:{src:e(400),alt:""}})]),t._v(" "),_("p",[t._v("Chrome里有一个主进程，就是Browser Process，其他的都是子进程。主进程负责状态栏，文件，网络等。Utility进程是辅助主进程，Renderer进程就是渲染进程。插件进程不管扩展。GPU进程用来做展示部分。")]),t._v(" "),_("ul",[_("li",[t._v('Browser: 控制程序的"Chrome"部分，包括地址栏，书签，后退和前进按钮。还处理Web浏览器的不可见的，和特权部分，例如网络请求和文件访问。')]),t._v(" "),_("li",[t._v("Renderer: 负责显示网站的选项卡内所有内容")]),t._v(" "),_("li",[t._v("Plugin: 控制网站使用的所有插件，例如Flash。")]),t._v(" "),_("li",[t._v("GPU: 独立于其他进程的GPU处理任务。它被分成多个不同的进程，因为GPU处理来自多个程序的请求并将它们绘制在同一个面中。")])]),t._v(" "),_("h3",{attrs:{id:"渲染进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程"}},[t._v("#")]),t._v(" 渲染进程")]),t._v(" "),_("p",[t._v("渲染进程负责选项卡内发生的所有事情。在渲染进程中，主线程处理你为用户编写的大部分代码。")]),t._v(" "),_("p",[t._v("如果使用了Web Worker 或 Service Worker，有时JS代码的一部分将由工作线程处理。排版和栅格线程也在渲染器进程内运行，以便高效、流畅地呈现页面。")]),t._v(" "),_("p",[_("img",{attrs:{src:e(401),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"渲染过程-解析部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程-解析部分"}},[t._v("#")]),t._v(" 渲染过程-解析部分")]),t._v(" "),_("ol",[_("li",[t._v("构建DOM。")]),t._v(" "),_("li",[t._v("子资源加载，如果发现有css png等资源，会同时加载。注意js可以阻止解析。当扫描到js时，DOM构建会暂停，会先去执行js。")]),t._v(" "),_("li",[t._v("提示浏览器如何加载资源")]),t._v(" "),_("li",[t._v("样式表计算  ----\x3e生成了渲染树")]),t._v(" "),_("li",[t._v("布局")]),t._v(" "),_("li",[t._v("绘制\n"),_("img",{attrs:{src:e(402),alt:""}})])]),t._v(" "),_("h3",{attrs:{id:"渲染过程-合成部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程-合成部分"}},[t._v("#")]),t._v(" 渲染过程-合成部分")]),t._v(" "),_("p",[t._v("光栅化把文档的结构、元素的样式、几何形状和绘制顺序转换为屏幕上的像素。")]),t._v(" "),_("p",[t._v("合成部分就是将页面的各个部分分层，分别栅格化，并在一个被称为合成器线程的独立线程中合成为页面的技术。\n"),_("img",{attrs:{src:e(403),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"渲染过程-gpu渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程-gpu渲染"}},[t._v("#")]),t._v(" 渲染过程- GPU渲染")]),t._v(" "),_("p",[t._v("GPU会把整个页面划分成若干个块(tile)，GPU是一个tile一个tile处理。为啥？这和GPU的结构有关系。CPU什么事情都能做，擅长做整数运算。但是处理图形的时候是浮点运算。GPU是众核处理器(超过48个)。GPU核简单，擅长处理浮点运算。")]),t._v(" "),_("p",[t._v("一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。合成器线程然后栅格化每个图层。一个图层可能像页面的整个长度一样大，因此合成器线程会将它们分成图块，并将每个图块发送到光栅线程。栅格线程栅格化每一个tile并将它们存储在GPU内存中。GPU渲染在独立的进程中，不会和处理JS的进程冲突。")]),t._v(" "),_("p",[t._v("通过IPC将合成器帧提交给浏览器进程。这时可以从UI线程添加另一个合成器帧以用于浏览器UI更改，或者从其他渲染器进程添加扩充数据。这些合成器帧被发送到GPU用来在屏幕上显示。如果发生滚动事件，合成器帧会创建另一个合成器帧并发送到GPU。")]),t._v(" "),_("p",[t._v("合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或JS执行。这就是合成动画是平滑性能的最佳选择的原因。如果需要再次计算布局或绘图，则必须涉及主线程。")]),t._v(" "),_("h2",{attrs:{id:"初窥webkit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初窥webkit"}},[t._v("#")]),t._v(" 初窥Webkit")]),t._v(" "),_("ul",[_("li",[t._v("webkit: https://webkit.org/")]),t._v(" "),_("li",[t._v("Blink是未来")]),t._v(" "),_("li",[t._v("Blink官方文档: http://www.chromium.org/blink\n"),_("img",{attrs:{src:e(404),alt:""}})])])])}),[],!1,null,null,null);r.default=s.exports}}]);