# Http 协议

Http 是超文本传输协议，它是一种通用的无状态的应用层协议。应用层定义在 OSI 七层模型中。

## OSI 七层模型

七层模型，亦称 OSI（Open System Interconnection）参考模型，是参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。

七层模型从上到下依次是：

- 应用层：协议有：HTTP FTP(文件传输协议) TFTP SMTP(邮件传输协议) SNMP(简单网络管理协议) DNS(域名系统) TELNET(远程登录标准协议) HTTPS POP3(邮局协议) DHCP(动态主机配置协议)
- 表示层：数据的表示、安全、压缩。格式有，JPEG、ASCll、DECOIC、加密格式等
- 会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用 MAC 地址访问介质，错误发现但不能纠正。
  物理层：建立、维护、断开物理连接。

![](./osi.png)

![](./osi2.png)

七层模型数据传输过程：
![](./transform_route.png)

## Http 请求过程

以访问百度为例，当我们在浏览器输入:www.baidu.com，回车之后，发生了什么？

1. 回车后对 www.baidu.com 这个网址进行 DNS 域名解析，得到对应的 IP 地址
2. 根据 IP 找到对应的服务器，发起 TCP 的三次握手
3. 建立 TCP 连接后发起 HTTP 请求
4. 服务器响应 HTTP 请求，浏览器得到 html 数据渲染

下面详细来看看这几个过程的具体细节。

### 域名解析

域名系统（DNS）我理解为一个管理主机域名和 IP 地址的系统。DNS 是一个分布式系统，域名解析是由分布在因特网上的许多域名服务器共同完成。

DNS 规定，域名中的符号都由英文和数字组成，每一个标号不超过 63 个字符，不区分字母大小写。

域名空间：
![](https://img-blog.csdn.net/20140506153156531)

一、主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。

二、本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

下图给出了这两种查询的差别
![](https://img-blog.csdn.net/20140507124241312)

假定域名为m.xyz.com的主机想知道另一个主机y.abc.com的IP地址。例如，主机m.xyz.com打算发送邮件给y.abc.com。这时就必须知道主机y.abc.com的IP地址。下面是上图a的几个查询步骤：

1、主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。

2、本地服务器采用迭代查询。它先向一个根域名服务器查询。

3、根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。

4、本地域名服务器向顶级域名服务器dns.com进行查询。

5、顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。

6、本地域名服务器向权限域名服务器dns.abc.com进行查询。

7、权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。

8、本地域名服务器最后把查询结果告诉m.xyz.com。

为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

回到我们的例子：
![](http://c.biancheng.net/uploads/allimg/191111/6-191111164422334.gif)

### TCP三次握手
TCP是传输控制协议。
- 它提供了一种面向连接的、可靠的字节流服务。
- 在一个TCP连接中，仅有两方进行通信，广播和多播不能用于TCP。
- TCP使用校验和、确认和重传机制来保证可靠传输。
- TCP给数据分节进行排序，并使用累计确认保证数据的顺序不变和不重复
- TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的代销进行拥塞控制

三次握手示意图：
![](https://upload-images.jianshu.io/upload_images/9658881-14388ff91eda35c6.png)

三次握手是指建立一个TCP连接时，需要客户端和服务器进行三次通信，发送3个包。
1. 第一次握手([SYN], Seq = x)
客户端发送一个SYN标记的包，Seq初始序列号，发送完成后客户端进去SYN_SEND状态。

2. 第二次握手([SYN, ACK], Seq = y, ACK = x + 1)
服务器返回确认包（ACK）应答，同事还要返回一个SYN包回去。ACK = x + 1 表示确认能收到客户端发来的请求。Seq = y 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。

3. 第三次握手([ACK], ACK = y + 1)
客户端再次发送确认包（ACK）， ACK = y + 1 表示确认收到服务器的包。客户端发送完毕后，进入ESTABLISHED状态，服务端收到这个包也进入ESTABLISHED状态， TCP握手结束。

### 四次挥手
TCP的断开需要发送四个包，称为四次挥手。
四次挥手示意图：
![](https://upload-images.jianshu.io/upload_images/9658881-bee754e3da92d278.png)

1. 第一次挥手（[FIN], Seq = x）
客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。

2. 第二次挥手([ACK], ACK = x + 1)
服务端收到请求后，发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后服务端进入CLOSE_WAIT状态，客户端收到这个包后进入FIN_WAIT_2，等待服务器关闭连接。

3. 第三次挥手([FIN], Seq = y)
服务器准备好关闭连接时，发送FIN标记的包，告诉客户端已经准备好可以关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。

4. 第四次挥手([ACK], ACK = y + 1)
客户端接收到服务端的关闭请求，发送ACK标记的包， 进入TIME_WAIT状态，等待服务端可能请求重传ACK包。服务端接收到ACK包后，关闭连接，进入CLOSE状态。


## Http请求特点
1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
3. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

## 状态码
状态代码一般由三位数字组成，第一个数字定义了响应的类别，共分五种类别:

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

## HTTP各版本分析

### HTTP/1.0
HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。


### HTTP/1.1
HTTP/1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。

目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

#### 缺点
虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

### SPDY 协议
2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。

这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。

### HTTP/2
2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

#### 1.二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

####  2.多工
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

####  3.数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

####  4.头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

####  5.服务器推送
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
